---
title: Menu Reference
sidebar:
  order: 52
---

This reference document covers the common menu item types and properties available in Wails v3. These features are shared between application menus and context menus.

## Menu Item Types

### Regular Menu Items

The most basic type of menu item displays text and triggers an action when clicked:

```go
menuItem := menu.Add("Click Me")
menuItem.OnClick(func(ctx *application.Context) {
    // Handle click
})
```

### Checkboxes

Checkbox menu items provide a toggleable state:

```go
checkbox := menu.AddCheckbox("Enable Feature", true)  // true = initially checked
checkbox.OnClick(func(ctx *application.Context) {
    isChecked := ctx.ClickedMenuItem().Checked()
    // Handle state change
})
```

### Radio Groups

Radio items create mutually exclusive options. Items are grouped automatically when placed adjacently:

```go
menu.AddRadio("Option 1", true)   // true = initially selected
menu.AddRadio("Option 2", false)
menu.AddRadio("Option 3", false)
```

### Submenus

Submenus allow you to create nested menu structures:

```go
submenu := menu.AddSubmenu("More Options")
submenu.Add("Submenu Item 1")
submenu.Add("Submenu Item 2")
```

### Separators

Separators add visual dividers between menu items:

```go
menu.Add("Item 1")
menu.AddSeparator()
menu.Add("Item 2")
```

## Menu Item Properties

### Label

The text displayed for the menu item:

```go
menuItem := menu.Add("Initial Label")
menuItem.SetLabel("New Label")
```

### Enabled State

Control whether the menu item can be interacted with:

```go
menuItem := menu.Add("Disabled Item")
menuItem.SetEnabled(false)
```

### Checked State

For checkbox and radio items, control or query their checked state:

```go
checkbox := menu.AddCheckbox("Feature", false)
checkbox.SetChecked(true)
isChecked := checkbox.Checked()
```

### Visibility

Control whether a menu item is visible using the `SetHidden` method, which works for all menu item types including submenus:

```go
menuItem := menu.Add("Regular Item")
menuItem.SetHidden(true)  // Hide the item
menuItem.SetHidden(false) // Show the item

// For submenus, use the same method
submenuItem := menu.AddSubmenu("Advanced Options")
submenuItem.SetHidden(true)  // Hide the submenu
submenuItem.SetHidden(false) // Show the submenu
```

### Accelerators

Add keyboard shortcuts to menu items:

```go
menuItem := menu.Add("Save")
menuItem.SetAccelerator("CmdOrCtrl+S")
```

Common accelerator modifiers:
- `CmdOrCtrl`: Command on macOS, Control on Windows/Linux
- `Shift`
- `Alt`: Option on macOS
- `Ctrl`: Control key on all platforms

## Menu Operations

### Adding Items

Standard methods for adding items to the end of a menu:

```go
menu.Add("Regular Item")
menu.AddCheckbox("Checkbox Item", false)
menu.AddRadio("Radio Item", false)
menu.AddSubmenu("Submenu")
menu.AddSeparator()
```

### Accessing Items by Index

Retrieve menu items using their index position:

```go
firstItem := menu.ItemAt(0)
secondItem := menu.ItemAt(1)

// Check if an item exists at the given index
if item := menu.ItemAt(5); item != nil {
    // Item exists, use it
}
```

### Inserting Items by Index

Insert items at specific positions in the menu. If the index is out of bounds, the item will be inserted at the beginning (for negative indices) or appended to the end (for indices greater than the menu length):

```go
// Insert a regular item at index 0 (beginning of the menu)
menu.InsertAt(0, "First Item")

// Insert a separator at index 2
menu.InsertSeparatorAt(2)

// Insert a checkbox at index 3
menu.InsertCheckboxAt(3, "Enable Feature", false)

// Insert a radio button at index 4
menu.InsertRadioAt(4, "Option", true)

// Insert a submenu at index 5
submenu := menu.InsertSubmenuAt(5, "More Options")

// Insert an existing menu item at index 6
existingItem := NewMenuItem("Existing Item")
menu.InsertItemAt(6, existingItem)

// Handling out-of-bounds indices
menu.InsertAt(-1, "Will be inserted at the beginning")
menu.InsertAt(999, "Will be appended to the end")
```

### Menu Size

Get the number of items in a menu:

```go
count := menu.Count()
```

## Event Handling

### Click Events

Handle menu item clicks using the `OnClick` method:

```go
menuItem.OnClick(func(ctx *application.Context) {
    // Access the clicked item
    clickedItem := ctx.ClickedMenuItem()
    
    // Get current state
    label := clickedItem.Label()
    isChecked := clickedItem.Checked()
    
    // Update the item
    clickedItem.SetLabel("New Label")
})
```

### Shared Event Handlers

Event handlers can be shared amongst multiple menu items:

```go
handleClick := func(ctx *application.Context) {
    item := ctx.ClickedMenuItem()
    // Common handling logic
}

menu.Add("Item 1").OnClick(handleClick)
menu.Add("Item 2").OnClick(handleClick)
```

## Dynamic Updates

Menu items can be updated dynamically during runtime:

```go
menuItem := menu.Add("Initial State")

// Later, update the item
menuItem.SetLabel("New Label")
menuItem.SetEnabled(false)
menuItem.SetChecked(true)
menuItem.SetHidden(true)  // Hide the item

// Apply changes
menu.Update()
```

:::note[Update Required]
After modifying menu items, call `Update()` on the parent menu to apply the changes.
:::

## Best Practices

1. Use clear, concise labels that describe the action
2. Group related items together using separators
3. Limit submenu depth to maintain usability
4. Provide keyboard shortcuts for common actions
5. Keep radio groups focused on a single choice
6. Update menu items to reflect application state
7. Handle all possible states in click handlers
8. Use index-based operations for dynamic menu restructuring
9. Use `SetHidden` consistently for all menu item types, including submenus

:::tip[Pro Tip]
When sharing event handlers, use the `ctx.ClickedMenuItem()` method to determine which item triggered the event and handle it accordingly.
:::

## Platform Considerations

:::note[Platform Behaviour]
Menu appearance and behaviour varies by platform:
- macOS: Uses native menu styling and supports system roles
- Windows: Follows Windows menu conventions
- Linux: Adapts to the desktop environment's theme
:::

:::danger[Warning]
Always test menu functionality across all supported platforms, as behaviour and appearance may vary significantly.
:::

## Example: Dynamic Menu Management

This example demonstrates how to dynamically manage menu items using the index-based operations:

```go
// Create a menu with some initial items
menu := application.NewMenu()
menu.Add("Item 1")
menu.Add("Item 3") // Intentionally skipping Item 2

// Later, insert the missing item at the correct position
menu.InsertAt(1, "Item 2")

// Get the count of items
fmt.Printf("Menu has %d items\n", menu.Count())

// Access items by index
for i := 0; i < menu.Count(); i++ {
    item := menu.ItemAt(i)
    fmt.Printf("Item at index %d: %s\n", i, item.Label())
}

// Show/hide a submenu based on application state
submenu := menu.AddSubmenu("Advanced Options")
if userIsAdvanced {
    submenu.SetHidden(false) // Show the submenu
} else {
    submenu.SetHidden(true)  // Hide the submenu
}

// Apply all changes
menu.Update()
```
